// Code generated by cmd/gen-meta from geppetto_codegen.yaml. DO NOT EDIT.

declare module "geppetto" {
    export const version: string;

    export interface Block {
        id?: string;
        kind: string;
        role?: string;
        payload?: Record<string, any>;
        metadata?: Record<string, any>;
        text?: string;
        args?: any;
        result?: any;
        name?: string;
        error?: string;
    }

    export interface Turn {
        id?: string;
        blocks: Block[];
        metadata?: Record<string, any>;
        data?: Record<string, any>;
    }

    export const consts: {
{{- range .Enums }}
        /** {{ .Doc }} */
        {{ .Name }}: {
{{- range .Values }}
            readonly {{ .JSKey }}: "{{ .Value }}";
{{- end }}
        };
{{- end }}
    };

    export interface Engine {
        name: string;
        metadata?: Record<string, any>;
    }

    export interface EngineOptions {
        model?: string;
        apiType?: string;
        provider?: string;
        temperature?: number;
        topP?: number;
        maxTokens?: number;
        timeoutSeconds?: number;
        timeoutMs?: number;
        apiKey?: string;
        baseURL?: string;
    }

    export interface ProfileEngineOptions {
        runtimeKey?: string;
        requestOverrides?: Record<string, any>;
    }

    export interface RegistrySummary {
        slug: string;
        display_name?: string;
        default_profile_slug?: string;
        profile_count: number;
    }

    export interface ProfileRef {
        registry_slug?: string;
        profile_slug: string;
    }

    export interface MiddlewareUse {
        name: string;
        id?: string;
        enabled?: boolean;
        config?: any;
    }

    export interface RuntimeSpec {
        step_settings_patch?: Record<string, any>;
        system_prompt?: string;
        middlewares?: MiddlewareUse[];
        tools?: string[];
    }

    export interface PolicySpec {
        allow_overrides?: boolean;
        allowed_override_keys?: string[];
        denied_override_keys?: string[];
        read_only?: boolean;
    }

    export interface ProfileMetadata {
        source?: string;
        version?: number;
        created_at_ms?: number;
        updated_at_ms?: number;
        created_by?: string;
        updated_by?: string;
        tags?: string[];
    }

    export interface RegistryMetadata {
        source?: string;
        version?: number;
        created_at_ms?: number;
        updated_at_ms?: number;
        created_by?: string;
        updated_by?: string;
        tags?: string[];
    }

    export interface Profile {
        slug: string;
        display_name?: string;
        description?: string;
        stack?: ProfileRef[];
        runtime?: RuntimeSpec;
        policy?: PolicySpec;
        metadata?: ProfileMetadata;
        extensions?: Record<string, any>;
    }

    export interface ProfileRegistry {
        slug: string;
        display_name?: string;
        description?: string;
        default_profile_slug?: string;
        profiles?: Record<string, Profile>;
        metadata?: RegistryMetadata;
    }

    export interface ProfilePatch {
        display_name?: string;
        description?: string;
        runtime?: RuntimeSpec;
        policy?: PolicySpec;
        metadata?: ProfileMetadata;
        extensions?: Record<string, any>;
    }

    export interface ProfileWriteOptions {
        expectedVersion?: number;
        actor?: string;
        source?: string;
    }

    export interface ProfileMutationOptions {
        registrySlug?: string;
        write?: ProfileWriteOptions;
    }

    export type ProfileRegistrySources = string | string[];

    export interface ConnectedProfileStack {
        sources: string[];
        registries: RegistrySummary[];
    }

    export interface ResolveInput {
        registrySlug?: string;
        profileSlug?: string;
        runtimeKeyFallback?: string;
        runtimeKey?: string;
        requestOverrides?: Record<string, any>;
    }

    export interface ResolvedProfile {
        registrySlug: string;
        profileSlug: string;
        runtimeKey: string;
        runtimeFingerprint: string;
        effectiveRuntime: RuntimeSpec;
        effectiveStepSettings?: Record<string, any>;
        metadata?: Record<string, any>;
    }

    export interface MiddlewareSchemaEntry {
        key: string;
        name: string;
        displayName?: string;
        description?: string;
        schema?: Record<string, any>;
    }

    export interface ExtensionSchemaEntry {
        key: string;
        displayName?: string;
        description?: string;
        schema?: Record<string, any>;
    }

    export interface ToolHookCallInfo {
        id: string;
        name: string;
        args: any;
    }

    export interface BeforeToolCallPayload {
        phase: "beforeToolCall";
        call: ToolHookCallInfo;
        timestampMs: number;
        sessionId?: string;
        inferenceId?: string;
        tags?: Record<string, any>;
    }

    export interface AfterToolCallPayload {
        phase: "afterToolCall";
        call: ToolHookCallInfo;
        result: { value: any; error: string; durationMs: number };
        timestampMs: number;
        sessionId?: string;
        inferenceId?: string;
        tags?: Record<string, any>;
    }

    export interface OnToolErrorPayload {
        phase: "onToolError";
        attempt: number;
        call: ToolHookCallInfo;
        error: string;
        defaultRetry: boolean;
        defaultBackoffMs: number;
        timestampMs: number;
        sessionId?: string;
        inferenceId?: string;
        tags?: Record<string, any>;
    }

    export interface ToolHooks {
        beforeToolCall?: (payload: BeforeToolCallPayload) =>
            void | { action?: "abort"; error?: string; call?: Partial<ToolHookCallInfo> };
        afterToolCall?: (payload: AfterToolCallPayload) =>
            void | { action?: "abort"; result?: any; error?: string };
        onToolError?: (payload: OnToolErrorPayload) =>
            void | { action?: "abort" | "retry" | "continue"; backoffMs?: number };
        hookErrorPolicy?: "fail-open" | "open" | "fail-closed";
        failOpen?: boolean;
        maxHookRetries?: number;
    }

    export interface ToolLoopSettings {
        enabled?: boolean;
        maxIterations?: number;
        maxParallelTools?: number;
        executionTimeoutMs?: number;
        toolChoice?: "auto" | "none" | "required";
        toolErrorHandling?: "continue" | "abort" | "retry";
        retryMaxRetries?: number;
        retryBackoffMs?: number;
        retryBackoffFactor?: number;
        allowedTools?: string[];
        hooks?: ToolHooks;
    }

    export interface MiddlewareContext {
        sessionId?: string;
        inferenceId?: string;
        traceId?: string;
        turnId?: string;
        middlewareName: string;
        timestampMs: number;
        deadlineMs?: number;
        tags?: Record<string, any>;
    }

    export type NextFn = (turn: Turn) => Turn;
    export type MiddlewareFn = (turn: Turn, next: NextFn, ctx?: MiddlewareContext) => Turn;

    export interface MiddlewareRef {
        type: "js" | "go";
        name: string;
        options?: Record<string, any>;
    }

    export interface ToolHandlerContext {
        toolName: string;
        timestampMs: number;
        sessionId?: string;
        inferenceId?: string;
        callId?: string;
        callName?: string;
        deadlineMs?: number;
        tags?: Record<string, any>;
    }

    export interface ToolHandler {
        (args: Record<string, any>, ctx?: ToolHandlerContext): any;
    }

    export interface ToolSpec {
        name: string;
        description?: string;
        parameters?: Record<string, any>;
        handler: ToolHandler;
    }

    export interface ToolInfo {
        name: string;
        description: string;
        version?: string;
        tags?: string[];
    }

    export interface ToolRegistry {
        register(spec: ToolSpec): ToolRegistry;
        useGoTools(names?: string[]): ToolRegistry;
        list(): ToolInfo[];
        call(name: string, args?: Record<string, any>): any;
    }

    export interface BuilderOptions {
        engine?: Engine;
        middlewares?: Array<MiddlewareRef | MiddlewareFn>;
        tools?: ToolRegistry;
        toolLoop?: ToolLoopSettings;
        toolHooks?: ToolHooks;
    }

    export interface Builder {
        withEngine(engine: Engine): Builder;
        useMiddleware(middleware: MiddlewareRef | MiddlewareFn): Builder;
        useGoMiddleware(name: string, options?: Record<string, any>): Builder;
        withTools(registry: ToolRegistry, loopSettings?: ToolLoopSettings): Builder;
        withToolLoop(settings: ToolLoopSettings): Builder;
        withToolHooks(hooks: ToolHooks): Builder;
        buildSession(): Session;
    }

    export interface Session {
        append(turn: Turn): Turn;
        latest(): Turn | null;
        turnCount(): number;
        turns(): Turn[];
        getTurn(index: number): Turn | null;
        turnsRange(start?: number, end?: number): Turn[];
        isRunning(): boolean;
        cancelActive(): void;
        run(seedTurn?: Turn, options?: RunOptions): Turn;
        runAsync(seedTurn?: Turn): Promise<Turn>;
        start(seedTurn?: Turn, options?: RunOptions): RunHandle;
    }

    export interface RunOptions {
        timeoutMs?: number;
        tags?: Record<string, any>;
    }

    export interface StreamEvent {
        type: string;
        sessionId?: string;
        inferenceId?: string;
        turnId?: string;
        timestampMs: number;
        delta?: string;
        completion?: string;
        text?: string;
        error?: string;
        rawPayload?: string;
        toolCall?: { id: string; name: string; input: string };
        toolResult?: { id: string; result: string };
        metaExtra?: Record<string, any>;
    }

    export interface RunHandle {
        promise: Promise<Turn>;
        cancel(): void;
        on(eventType: string, callback: (event: StreamEvent) => void): RunHandle;
    }

    export const turns: {
        normalize(turn: Turn): Turn;
        newTurn(data?: Partial<Turn>): Turn;
        appendBlock(turn: Turn, block: Block): Turn;
        newUserBlock(text: string): Block;
        newSystemBlock(text: string): Block;
        newAssistantBlock(text: string): Block;
        newToolCallBlock(id: string, name: string, args: any): Block;
        newToolUseBlock(id: string, result: any, error?: string): Block;
    };

    export const engines: {
        echo(options?: { reply?: string }): Engine;
        fromProfile(profile?: string, options?: ProfileEngineOptions): Engine;
        fromConfig(options: EngineOptions): Engine;
        fromFunction(fn: (turn: Turn) => Turn | void): Engine;
    };

    export const profiles: {
        listRegistries(): RegistrySummary[];
        getRegistry(registrySlug?: string): ProfileRegistry;
        listProfiles(registrySlug?: string): Profile[];
        getProfile(profileSlug: string, registrySlug?: string): Profile;
        resolve(input?: ResolveInput): ResolvedProfile;
        createProfile(profile: Profile, options?: ProfileMutationOptions): Profile;
        updateProfile(profileSlug: string, patch: ProfilePatch, options?: ProfileMutationOptions): Profile;
        deleteProfile(profileSlug: string, options?: ProfileMutationOptions): void;
        setDefaultProfile(profileSlug: string, options?: ProfileMutationOptions): void;
        connectStack(sources: ProfileRegistrySources): ConnectedProfileStack;
        disconnectStack(): void;
        getConnectedSources(): string[];
    };

    export const schemas: {
        listMiddlewares(): MiddlewareSchemaEntry[];
        listExtensions(): ExtensionSchemaEntry[];
    };

    export const middlewares: {
        fromJS(fn: MiddlewareFn, name?: string): MiddlewareRef;
        go(name: string, options?: Record<string, any>): MiddlewareRef;
    };

    export const tools: {
        createRegistry(): ToolRegistry;
    };

    export function createBuilder(options?: BuilderOptions): Builder;
    export function createSession(options: BuilderOptions): Session;
    export function runInference(engine: Engine, turn: Turn, options?: BuilderOptions): Turn;
}
