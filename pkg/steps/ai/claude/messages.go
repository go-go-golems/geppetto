package claude

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"io"
	"net/http"
)

// TODO(manuel, 2024-04-07) This is WIP code, most of it generated by an LLM. Do not use.

// MessageRequest represents the Messages API request payload.
type MessageRequest struct {
	Model         string    `json:"model"`
	Messages      []Message `json:"messages"`
	MaxTokens     int       `json:"max_tokens"`
	Metadata      *Metadata `json:"metadata,omitempty"`
	StopSequences []string  `json:"stop_sequences,omitempty"`
	Stream        bool      `json:"stream"`
	System        string    `json:"system,omitempty"`
	Temperature   *float64  `json:"temperature,omitempty"`
	Tools         []Tool    `json:"tools,omitempty"`
	TopK          *int      `json:"top_k,omitempty"`
	TopP          *float64  `json:"top_p,omitempty"`
}

// Tool represents a tool that the model can use.
type Tool struct {
	Name        string      `json:"name"`
	Description string      `json:"description,omitempty"`
	InputSchema interface{} `json:"input_schema"` // JSON schema for the tool input
}

// Message represents a single message in the conversation.
type Message struct {
	Role    string      `json:"role"`
	Content interface{} `json:"content"` // Can be a string or an array of content blocks
}

// UnmarshalJSON implements the json.Unmarshaler interface for Message.
func (m *Message) UnmarshalJSON(data []byte) error {
	var rawMessage struct {
		Role    string          `json:"role"`
		Content json.RawMessage `json:"content"`
	}

	err := json.Unmarshal(data, &rawMessage)
	if err != nil {
		return err
	}

	m.Role = rawMessage.Role

	// Try to unmarshal content as a string
	var contentString string
	err = json.Unmarshal(rawMessage.Content, &contentString)
	if err == nil {
		m.Content = contentString
		return nil
	}

	// Try to unmarshal content as a []Content
	var contentBlocks []Content
	err = json.Unmarshal(rawMessage.Content, &contentBlocks)
	if err == nil {
		m.Content = contentBlocks
		return nil
	}

	return errors.New("invalid content format")
}

// MessageResponse represents the Messages API response payload.
type MessageResponse struct {
	ID           string    `json:"id"`
	Type         string    `json:"type"`
	Role         string    `json:"role"`
	Content      []Content `json:"content"`
	Model        string    `json:"model"`
	StopReason   string    `json:"stop_reason,omitempty"`
	StopSequence string    `json:"stop_sequence,omitempty"`
	Usage        Usage     `json:"usage"`
}

// Content represents a single block of content, which can be of various types.
type Content struct {
	Type    string          `json:"type"`
	Text    *string         `json:"text,omitempty"`
	Image   *ImageContent   `json:"image,omitempty"`
	ToolUse *ToolUseContent `json:"tool_use,omitempty"`
}

// MarshalJSON implements the json.Marshaler interface for Content.
func (c Content) MarshalJSON() ([]byte, error) {
	switch c.Type {
	case "text":
		if c.Text == nil {
			return nil, errors.New("text content is nil")
		}
		return json.Marshal(struct {
			Type string `json:"type"`
			Text string `json:"text"`
		}{
			Type: c.Type,
			Text: *c.Text,
		})

	case "image":
		if c.Image == nil {
			return nil, errors.New("image content is nil")
		}
		return json.Marshal(struct {
			Type  string       `json:"type"`
			Image ImageContent `json:"image"`
		}{
			Type:  c.Type,
			Image: *c.Image,
		})

	case "tool_use":
		if c.ToolUse == nil {
			return nil, errors.New("tool use content is nil")
		}
		return json.Marshal(struct {
			Type    string         `json:"type"`
			ToolUse ToolUseContent `json:"tool_use"`
		}{
			Type:    c.Type,
			ToolUse: *c.ToolUse,
		})

	default:
		return nil, errors.New("unknown content type")
	}
}

// ImageContent represents an image content block.
type ImageContent struct {
	Source ImageSource `json:"source"`
}

// ImageSource represents the source of an image, which can be a base64-encoded string.
type ImageSource struct {
	Type      string `json:"type"`       // e.g., "base64"
	MediaType string `json:"media_type"` // e.g., "image/jpeg"
	Data      string `json:"data"`
}

// ToolUseContent represents a content block where the model uses a tool.
type ToolUseContent struct {
	ID     string          `json:"id"`
	Name   string          `json:"name"`
	Input  json.RawMessage `json:"input"`            // JSON structure for the tool input
	Result *string         `json:"result,omitempty"` // Optional result of the tool use
}

// NewTextContent creates a new text content block.
func NewTextContent(text string) Content {
	return Content{
		Type: "text",
		Text: &text,
	}
}

// NewImageContent creates a new image content block with base64-encoded data.
func NewImageContent(mediaType, base64Data string) Content {
	return Content{
		Type: "image",
		Image: &ImageContent{
			Source: ImageSource{
				Type:      "base64",
				MediaType: mediaType,
				Data:      base64Data,
			},
		},
	}
}

// NewToolUseContent creates a new tool use content block.
func NewToolUseContent(toolID, toolName string, toolInput json.RawMessage) Content {
	return Content{
		Type: "tool_use",
		ToolUse: &ToolUseContent{
			ID:    toolID,
			Name:  toolName,
			Input: toolInput,
		},
	}
}

// Usage represents the billing and rate-limit usage information.
type Usage struct {
	InputTokens  int `json:"input_tokens"`
	OutputTokens int `json:"output_tokens"`
}

// SendMessage sends a message request and returns the response.
func (c *Client) SendMessage(ctx context.Context, req *MessageRequest) (*MessageResponse, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}

	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.BaseURL+"/v1/messages", bytes.NewBuffer(body))
	if err != nil {
		return nil, err
	}
	c.setHeaders(httpReq)

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, err
	}
	defer func(Body io.ReadCloser) {
		_ = Body.Close()
	}(resp.Body)

	if resp.StatusCode != http.StatusOK {
		var errorResp ErrorResponse
		respBody, _ := io.ReadAll(resp.Body)
		if unmarshalErr := json.Unmarshal(respBody, &errorResp); unmarshalErr != nil {
			return nil, unmarshalErr
		}
		return nil, errors.New(errorResp.Error.Message)
	}

	var messageResp MessageResponse
	respBody, _ := io.ReadAll(resp.Body)
	if unmarshalErr := json.Unmarshal(respBody, &messageResp); unmarshalErr != nil {
		return nil, unmarshalErr
	}

	return &messageResp, nil
}

// StreamMessage sends a message request and returns a channel of Events for streaming responses.
func (c *Client) StreamMessage(ctx context.Context, req *MessageRequest) (<-chan StreamingEvent, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}

	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, c.BaseURL+"/v1/messages", bytes.NewBuffer(body))
	if err != nil {
		return nil, err
	}
	c.setHeaders(httpReq)

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		defer func(Body io.ReadCloser) {
			_ = Body.Close()
		}(resp.Body)
		var errorResp ErrorResponse
		respBody, _ := io.ReadAll(resp.Body)
		if unmarshalErr := json.Unmarshal(respBody, &errorResp); unmarshalErr != nil {
			return nil, unmarshalErr
		}
		return nil, errors.New(errorResp.Error.Message)
	}

	events := make(chan StreamingEvent)
	go func() {
		defer close(events)
		streamEvents(ctx, resp, events)
	}()

	return events, nil
}
