// Code generated by cmd/gen-js-api from geppetto.d.ts.tmpl + js_api_codegen.yaml. DO NOT EDIT.

declare module "geppetto" {
    export const version: string;

    export interface Block {
        id?: string;
        kind: string;
        role?: string;
        payload?: Record<string, any>;
        metadata?: Record<string, any>;
        text?: string;
        args?: any;
        result?: any;
        name?: string;
        error?: string;
    }

    export interface Turn {
        id?: string;
        blocks: Block[];
        metadata?: Record<string, any>;
        data?: Record<string, any>;
    }

    export const consts: {
        /** How the model should choose tools */
        ToolChoice: {
            readonly AUTO: "auto";
            readonly NONE: "none";
            readonly REQUIRED: "required";
        };
        /** How to handle tool execution errors */
        ToolErrorHandling: {
            readonly CONTINUE: "continue";
            readonly ABORT: "abort";
            readonly RETRY: "retry";
        };
        /** The kind of a block within a Turn */
        BlockKind: {
            readonly USER: "user";
            readonly LLM_TEXT: "llm_text";
            readonly TOOL_CALL: "tool_call";
            readonly TOOL_USE: "tool_use";
            readonly SYSTEM: "system";
            readonly REASONING: "reasoning";
            readonly OTHER: "other";
        };
        /** Actions returned from tool hook callbacks */
        HookAction: {
            readonly ABORT: "abort";
            readonly RETRY: "retry";
            readonly CONTINUE: "continue";
        };
        /** Standard turn metadata key names */
        MetadataKeys: {
            readonly PROVIDER: "provider";
            readonly RUNTIME: "runtime";
            readonly SESSION_ID: "session_id";
            readonly INFERENCE_ID: "inference_id";
            readonly TRACE_ID: "trace_id";
            readonly USAGE: "usage";
            readonly STOP_REASON: "stop_reason";
            readonly MODEL: "model";
        };
        /** Streaming event types for RunHandle.on() */
        EventType: {
            readonly START: "start";
            readonly PARTIAL: "partial";
            readonly FINAL: "final";
            readonly TOOL_CALL: "tool-call";
            readonly TOOL_RESULT: "tool-result";
            readonly ERROR: "error";
        };
    };

    export interface Engine {
        name: string;
    }

    export interface EngineOptions {
        model?: string;
        apiType?: string;
        provider?: string;
        profile?: string;
        temperature?: number;
        topP?: number;
        maxTokens?: number;
        timeoutSeconds?: number;
        timeoutMs?: number;
        apiKey?: string;
        baseURL?: string;
    }

    export interface ToolHookCallInfo {
        id: string;
        name: string;
        args: any;
    }

    export interface BeforeToolCallPayload {
        phase: "beforeToolCall";
        call: ToolHookCallInfo;
        timestampMs: number;
    }

    export interface AfterToolCallPayload {
        phase: "afterToolCall";
        call: ToolHookCallInfo;
        result: { value: any; error: string; durationMs: number };
        timestampMs: number;
    }

    export interface OnToolErrorPayload {
        phase: "onToolError";
        attempt: number;
        call: ToolHookCallInfo;
        error: string;
        defaultRetry: boolean;
        defaultBackoffMs: number;
        timestampMs: number;
    }

    export interface ToolHooks {
        beforeToolCall?: (payload: BeforeToolCallPayload) =>
            void | { action?: "abort"; error?: string; call?: Partial<ToolHookCallInfo> };
        afterToolCall?: (payload: AfterToolCallPayload) =>
            void | { action?: "abort"; result?: any; error?: string };
        onToolError?: (payload: OnToolErrorPayload) =>
            void | { action?: "abort" | "retry" | "continue"; backoffMs?: number };
        hookErrorPolicy?: "fail-open" | "open" | "fail-closed";
        failOpen?: boolean;
        maxHookRetries?: number;
    }

    export interface ToolLoopSettings {
        enabled?: boolean;
        maxIterations?: number;
        maxParallelTools?: number;
        executionTimeoutMs?: number;
        toolChoice?: "auto" | "none" | "required";
        toolErrorHandling?: "continue" | "abort" | "retry";
        retryMaxRetries?: number;
        retryBackoffMs?: number;
        retryBackoffFactor?: number;
        allowedTools?: string[];
        hooks?: ToolHooks;
    }

    export type NextFn = (turn: Turn) => Turn;
    export type MiddlewareFn = (turn: Turn, next: NextFn) => Turn;

    export interface MiddlewareRef {
        type: "js" | "go";
        name: string;
        options?: Record<string, any>;
    }

    export interface ToolHandler {
        (args: Record<string, any>): any;
    }

    export interface ToolSpec {
        name: string;
        description?: string;
        parameters?: Record<string, any>;
        handler: ToolHandler;
    }

    export interface ToolInfo {
        name: string;
        description: string;
        version?: string;
        tags?: string[];
    }

    export interface ToolRegistry {
        register(spec: ToolSpec): ToolRegistry;
        useGoTools(names?: string[]): ToolRegistry;
        list(): ToolInfo[];
        call(name: string, args?: Record<string, any>): any;
    }

    export interface BuilderOptions {
        engine?: Engine;
        middlewares?: Array<MiddlewareRef | MiddlewareFn>;
        tools?: ToolRegistry;
        toolLoop?: ToolLoopSettings;
        toolHooks?: ToolHooks;
    }

    export interface Builder {
        withEngine(engine: Engine): Builder;
        useMiddleware(middleware: MiddlewareRef | MiddlewareFn): Builder;
        useGoMiddleware(name: string, options?: Record<string, any>): Builder;
        withTools(registry: ToolRegistry, loopSettings?: ToolLoopSettings): Builder;
        withToolLoop(settings: ToolLoopSettings): Builder;
        withToolHooks(hooks: ToolHooks): Builder;
        buildSession(): Session;
    }

    export interface Session {
        append(turn: Turn): Turn;
        latest(): Turn | null;
        turnCount(): number;
        turns(): Turn[];
        getTurn(index: number): Turn | null;
        turnsRange(start?: number, end?: number): Turn[];
        isRunning(): boolean;
        cancelActive(): void;
        run(seedTurn?: Turn): Turn;
        runAsync(seedTurn?: Turn): Promise<Turn>;
    }

    export const turns: {
        normalize(turn: Turn): Turn;
        newTurn(data?: Partial<Turn>): Turn;
        appendBlock(turn: Turn, block: Block): Turn;
        newUserBlock(text: string): Block;
        newSystemBlock(text: string): Block;
        newAssistantBlock(text: string): Block;
        newToolCallBlock(id: string, name: string, args: any): Block;
        newToolUseBlock(id: string, result: any, error?: string): Block;
    };

    export const engines: {
        echo(options?: { reply?: string }): Engine;
        fromProfile(profile?: string, options?: EngineOptions): Engine;
        fromConfig(options: EngineOptions): Engine;
        fromFunction(fn: (turn: Turn) => Turn | void): Engine;
    };

    export const middlewares: {
        fromJS(fn: MiddlewareFn, name?: string): MiddlewareRef;
        go(name: string, options?: Record<string, any>): MiddlewareRef;
    };

    export const tools: {
        createRegistry(): ToolRegistry;
    };

    export function createBuilder(options?: BuilderOptions): Builder;
    export function createSession(options: BuilderOptions): Session;
    export function runInference(engine: Engine, turn: Turn, options?: BuilderOptions): Turn;
}
