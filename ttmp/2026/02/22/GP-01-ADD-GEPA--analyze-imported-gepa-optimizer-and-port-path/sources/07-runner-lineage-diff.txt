Generated: 2026-02-22T17:24:24-05:00

== plugin_loader.go: cozo runner vs gepa-runner ==
--- 2026-02-18--cozodb-extraction/cozo-relationship-js-runner/plugin_loader.go	2026-02-22 17:02:04.630587595 -0500
+++ imported/geppetto-main/cmd/gepa-runner/plugin_loader.go	2026-02-22 16:56:52.000000000 -0500
@@ -7,180 +7,143 @@
 
 	"github.com/dop251/goja"
 	"github.com/dop251/goja_nodejs/require"
+	gepaopt "github.com/go-go-golems/geppetto/pkg/optimizer/gepa"
 	"github.com/pkg/errors"
 )
 
-const extractorPluginAPIVersion = "cozo.extractor/v1"
+const optimizerPluginAPIVersion = "gepa.optimizer/v1"
 
-type extractorPluginMeta struct {
+type optimizerPluginMeta struct {
 	APIVersion string
 	Kind       string
 	ID         string
 	Name       string
 }
 
-func (m extractorPluginMeta) toMap() map[string]any {
-	return map[string]any{
-		"plugin_mode":        "descriptor",
-		"plugin_api_version": m.APIVersion,
-		"plugin_kind":        m.Kind,
-		"plugin_id":          m.ID,
-		"plugin_name":        m.Name,
-	}
-}
-
-type extractorPluginRunRequest struct {
-	Transcript    string
-	Prompt        string
-	Profile       string
-	TimeoutMs     int
-	EngineOptions map[string]any
-}
-
-type canonicalExtractorRunInput struct {
-	Transcript    string
-	Prompt        string
+type pluginEvaluateOptions struct {
 	Profile       string
-	TimeoutMs     int
 	EngineOptions map[string]any
+	Tags          map[string]any
 }
 
-func canonicalizeExtractorRunInput(req extractorPluginRunRequest) (canonicalExtractorRunInput, error) {
-	if strings.TrimSpace(req.Transcript) == "" {
-		return canonicalExtractorRunInput{}, fmt.Errorf("input.transcript is required")
-	}
-	timeoutMs := req.TimeoutMs
-	if timeoutMs <= 0 {
-		timeoutMs = 120000
-	}
-
-	var engineOptions map[string]any
-	if len(req.EngineOptions) > 0 {
-		engineOptions = make(map[string]any, len(req.EngineOptions))
-		for k, v := range req.EngineOptions {
-			engineOptions[k] = v
-		}
-	}
+type optimizerPlugin struct {
+	rt       *jsRuntime
+	meta     optimizerPluginMeta
+	instance *goja.Object
 
-	return canonicalExtractorRunInput{
-		Transcript:    req.Transcript,
-		Prompt:        strings.TrimSpace(req.Prompt),
-		Profile:       strings.TrimSpace(req.Profile),
-		TimeoutMs:     timeoutMs,
-		EngineOptions: engineOptions,
-	}, nil
+	evaluateFn goja.Callable
+	datasetFn  goja.Callable
 }
 
-func loadAndRunExtractorPlugin(
-	vm *goja.Runtime,
-	reqMod *require.RequireModule,
-	absScriptPath string,
-	req extractorPluginRunRequest,
-	hostContext map[string]any,
-) (any, extractorPluginMeta, error) {
-	if vm == nil {
-		return nil, extractorPluginMeta{}, errors.New("plugin loader: runtime is nil")
-	}
-	if reqMod == nil {
-		return nil, extractorPluginMeta{}, errors.New("plugin loader: require module is nil")
+func loadOptimizerPlugin(rt *jsRuntime, absScriptPath string, hostContext map[string]any) (*optimizerPlugin, optimizerPluginMeta, error) {
+	if rt == nil || rt.vm == nil || rt.reqMod == nil {
+		return nil, optimizerPluginMeta{}, errors.New("plugin loader: runtime is nil")
 	}
 	if strings.TrimSpace(absScriptPath) == "" {
-		return nil, extractorPluginMeta{}, errors.New("plugin loader: script path is empty")
+		return nil, optimizerPluginMeta{}, errors.New("plugin loader: script path is empty")
 	}
 
-	exported, err := reqMod.Require(absScriptPath)
+	// NOTE: require expects absolute path for local files when we use abs path.
+	var exported goja.Value
+	var err error
+	exported, err = rt.reqMod.Require(absScriptPath)
 	if err != nil {
-		return nil, extractorPluginMeta{}, errors.Wrap(err, "plugin loader: require script module")
+		return nil, optimizerPluginMeta{}, errors.Wrap(err, "plugin loader: require script module")
 	}
-	descriptorObj := exported.ToObject(vm)
+
+	descriptorObj := exported.ToObject(rt.vm)
 	if descriptorObj == nil {
-		return nil, extractorPluginMeta{}, fmt.Errorf("plugin loader: script module did not export an object descriptor")
+		return nil, optimizerPluginMeta{}, fmt.Errorf("plugin loader: script module did not export an object descriptor")
 	}
 
-	meta, err := decodeExtractorPluginMeta(descriptorObj)
+	meta, err := decodeOptimizerPluginMeta(descriptorObj)
 	if err != nil {
-		return nil, extractorPluginMeta{}, err
+		return nil, optimizerPluginMeta{}, err
 	}
 
 	createVal := descriptorObj.Get("create")
 	createFn, ok := goja.AssertFunction(createVal)
 	if !ok {
-		return nil, extractorPluginMeta{}, fmt.Errorf("plugin loader: descriptor.create must be a function")
+		return nil, optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.create must be a function")
 	}
 
 	if hostContext == nil {
 		hostContext = map[string]any{}
 	}
-	instanceVal, err := createFn(descriptorObj, vm.ToValue(hostContext))
+
+	instanceVal, err := createFn(descriptorObj, rt.vm.ToValue(hostContext))
 	if err != nil {
-		return nil, extractorPluginMeta{}, errors.Wrap(err, "plugin loader: descriptor.create failed")
+		return nil, optimizerPluginMeta{}, errors.Wrap(err, "plugin loader: descriptor.create failed")
 	}
-	instanceObj := instanceVal.ToObject(vm)
+	instanceObj := instanceVal.ToObject(rt.vm)
 	if instanceObj == nil {
-		return nil, extractorPluginMeta{}, fmt.Errorf("plugin loader: descriptor.create must return an object instance")
+		return nil, optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.create must return an object instance")
 	}
 
-	runVal := instanceObj.Get("run")
-	runFn, ok := goja.AssertFunction(runVal)
+	evaluateVal := instanceObj.Get("evaluate")
+	evaluateFn, ok := goja.AssertFunction(evaluateVal)
 	if !ok {
-		return nil, extractorPluginMeta{}, fmt.Errorf("plugin loader: plugin instance.run must be a function")
+		return nil, optimizerPluginMeta{}, fmt.Errorf("plugin loader: plugin instance.evaluate must be a function")
 	}
 
-	canonicalInput, err := canonicalizeExtractorRunInput(req)
-	if err != nil {
-		return nil, extractorPluginMeta{}, errors.Wrap(err, "plugin loader: invalid run input")
-	}
-
-	input := map[string]any{
-		"transcript":    canonicalInput.Transcript,
-		"prompt":        canonicalInput.Prompt,
-		"profile":       canonicalInput.Profile,
-		"timeoutMs":     canonicalInput.TimeoutMs,
-		"engineOptions": canonicalInput.EngineOptions,
+	// dataset() is optional if dataset file is provided, but weâ€™ll attempt to bind it here.
+	var datasetFn goja.Callable
+	if dv := instanceObj.Get("dataset"); dv != nil && !goja.IsUndefined(dv) && !goja.IsNull(dv) {
+		if fn, ok := goja.AssertFunction(dv); ok {
+			datasetFn = fn
+		}
 	}
-	runOptions := map[string]any{
-		"timeoutMs": canonicalInput.TimeoutMs,
-		"tags": map[string]any{
-			"app":    "cozo-relationship-js-runner",
-			"source": "plugin-descriptor",
-		},
+	if datasetFn == nil {
+		if dv := instanceObj.Get("getDataset"); dv != nil && !goja.IsUndefined(dv) && !goja.IsNull(dv) {
+			if fn, ok := goja.AssertFunction(dv); ok {
+				datasetFn = fn
+			}
+		}
 	}
 
-	ret, err := runFn(instanceObj, vm.ToValue(input), vm.ToValue(runOptions))
-	if err != nil {
-		return nil, extractorPluginMeta{}, errors.Wrap(err, "plugin loader: plugin instance.run failed")
+	p := &optimizerPlugin{
+		rt:         rt,
+		meta:       meta,
+		instance:   instanceObj,
+		evaluateFn: evaluateFn,
+		datasetFn:  datasetFn,
 	}
 
-	decoded, err := decodePluginReturnValue(ret)
-	if err != nil {
-		return nil, extractorPluginMeta{}, errors.Wrap(err, "plugin loader: invalid plugin return value")
-	}
-	return decoded, meta, nil
+	return p, meta, nil
 }
 
-func decodeExtractorPluginMeta(descriptorObj *goja.Object) (extractorPluginMeta, error) {
+func decodeOptimizerPluginMeta(descriptorObj *goja.Object) (optimizerPluginMeta, error) {
+
 	apiVersion := strings.TrimSpace(descriptorObj.Get("apiVersion").String())
 	kind := strings.TrimSpace(descriptorObj.Get("kind").String())
 	id := strings.TrimSpace(descriptorObj.Get("id").String())
 	name := strings.TrimSpace(descriptorObj.Get("name").String())
 
 	if apiVersion == "" {
-		return extractorPluginMeta{}, fmt.Errorf("plugin loader: descriptor.apiVersion is required")
+		return optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.apiVersion is required")
 	}
-	if apiVersion != extractorPluginAPIVersion {
-		return extractorPluginMeta{}, fmt.Errorf("plugin loader: unsupported apiVersion %q (expected %q)", apiVersion, extractorPluginAPIVersion)
+	if apiVersion != optimizerPluginAPIVersion {
+		return optimizerPluginMeta{}, fmt.Errorf("plugin loader: unsupported apiVersion %q (expected %q)", apiVersion, optimizerPluginAPIVersion)
 	}
-	if kind != "extractor" {
-		return extractorPluginMeta{}, fmt.Errorf("plugin loader: descriptor.kind must be %q", "extractor")
+	if kind != "optimizer" {
+		return optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.kind must be %q", "optimizer")
 	}
 	if id == "" {
-		return extractorPluginMeta{}, fmt.Errorf("plugin loader: descriptor.id is required")
+		return optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.id is required")
 	}
 	if name == "" {
-		return extractorPluginMeta{}, fmt.Errorf("plugin loader: descriptor.name is required")
+		return optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.name is required")
+	}
+
+	// Sanity: ensure descriptor.create exists.
+	if cv := descriptorObj.Get("create"); cv == nil || goja.IsUndefined(cv) || goja.IsNull(cv) {
+		return optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.create is required")
+	}
+	if _, ok := goja.AssertFunction(descriptorObj.Get("create")); !ok {
+		return optimizerPluginMeta{}, fmt.Errorf("plugin loader: descriptor.create must be a function")
 	}
 
-	return extractorPluginMeta{
+	return optimizerPluginMeta{
 		APIVersion: apiVersion,
 		Kind:       kind,
 		ID:         id,
@@ -188,15 +151,90 @@
 	}, nil
 }
 
-func decodePluginReturnValue(ret goja.Value) (any, error) {
+func (p *optimizerPlugin) Dataset() ([]any, error) {

== main.go profile/env helper overlap indicators ==
imported/geppetto-main/cmd/gepa-runner/profile_helpers.go:11:func applyProfileEnvironment(profile string, parsedValues *values.Values) error {
imported/geppetto-main/cmd/gepa-runner/profile_helpers.go:31:func resolvePinocchioProfile(parsedValues *values.Values) (string, error) {
imported/geppetto-main/cmd/gepa-runner/profile_helpers.go:41:func resolveEngineOptions(parsedValues *values.Values) (map[string]any, error) {
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:521:func applyProfileEnvironment(profile string, parsedValues *values.Values) error {
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:541:func resolvePinocchioProfile(parsedValues *values.Values) (string, error) {
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:551:func resolveEngineOptions(parsedValues *values.Values) (map[string]any, error) {

== js runtime construction overlap indicators ==
imported/geppetto-main/cmd/gepa-runner/js_runtime.go:33:	loop := eventloop.NewEventLoop()
imported/geppetto-main/cmd/gepa-runner/js_runtime.go:37:	runner := runtimeowner.NewRunner(vm, loop, runtimeowner.Options{
imported/geppetto-main/cmd/gepa-runner/js_runtime.go:42:	reg := require.NewRegistry(
imported/geppetto-main/cmd/gepa-runner/js_runtime.go:47:	if err := installConsoleAndHelpers(vm); err != nil {
imported/geppetto-main/cmd/gepa-runner/js_runtime.go:53:	gp.Register(reg, gp.Options{
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:408:	loop := eventloop.NewEventLoop()
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:413:	runner := runtimeowner.NewRunner(vm, loop, runtimeowner.Options{
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:418:	reg := require.NewRegistry(
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:433:	gp.Register(reg, gpOptions)
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:448:	if err := installConsoleAndHelpers(vm); err != nil {
2026-02-18--cozodb-extraction/cozo-relationship-js-runner/main.go:635:func installConsoleAndHelpers(vm *goja.Runtime) error {
