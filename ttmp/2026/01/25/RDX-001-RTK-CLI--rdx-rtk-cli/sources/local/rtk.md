**Introduction & Overview**  
Redux DevTools is a development toolset that lets you inspect and manipulate a Redux application’s state. In remote debugging scenarios, where the app is not running in a browser (e.g. a React Native app or a back-end service), a **remote DevTools protocol** is used to communicate between the application and the DevTools UI (monitor) via a WebSocket server. This protocol involves a **SocketCluster** transport and a structured message format (often serialized with a custom JSON serializer called JSAN). Understanding this protocol is key to implementing custom DevTools clients or servers and ensuring compatibility with official Redux DevTools. This guide covers the transport layer, message schemas, the lifted state structure for time-travel debugging, the roles of app vs. monitor, persistence of debug sessions, integration steps, and troubleshooting.

**Transport Layer (SocketCluster Communication)**  
The Redux remote DevTools uses SocketCluster – a publish/subscribe WebSocket framework – for communication. By default, the DevTools server runs a SocketCluster instance listening on the path **`/socketcluster/`** (port 8000 on localhost by default)[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=The%20client%20driver%20provides%20us,server%20is%20running%20on%20ws%3A%2F%2Flocalhost%3A8000%2Fsocketcluster). Both the application (client) and the DevTools monitor (UI) connect to this WebSocket endpoint.

**Connection Handshake:** Once connected, clients perform a simple authentication handshake. Specifically, a client will emit a `"login"` event. The DevTools monitor typically identifies itself by sending the string `"master"` as login payload[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=3,Channel%20of%20Events), whereas an application client can connect without special credentials (the server will assign it an ID). On a successful login, the SocketCluster server returns a **channel name** (a unique identifier, often based on the socket ID or a generated instance ID) that the client should subscribe to[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=login%28%29%20,break). This channel is used for directed messages: the server will forward monitor commands to the app on this private channel, and possibly use it to tag messages. The monitor, after logging in as master, may subscribe to a general channel (or all client channels) to receive updates from all apps, or the server might forward all app messages to the master channel. In practice, the official server uses specific channels like `"log"`/`"log-noid"` for incoming data and `"respond"` for outgoing commands, abstracting the actual socket IDs.

**Channels and Event Routing:**

-   **`log` vs `log-noid`:** The application publishes its Redux actions and state changes over a channel named `"log"` (for normal operation). Initially, if the app hasn’t received its unique channel ID yet, it can use `"log-noid"`; the server will then attach the socket ID to these messages server-side[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=We%20can%20use%20log%20or,before%20the%20connection%20was%20established). In essence, the app sends on `"log-noid"` until the server responds with an assigned ID, after which the app switches to its dedicated `"log"` channel (often suffixed with its id). This ensures no data is lost if actions are dispatched very quickly on startup.
    
-   **Private channels (e.g. `sc-{id}`):** Under the hood, the SocketCluster server often creates a private channel for each client (commonly the channel name returned on login). The app subscribes to this channel to listen for monitor messages (such as time-travel commands). The code, for example, does: `channelName = await socket.invoke('login', 'master'); socket.subscribe(channelName)` to start listening[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=login%28%29%20,break). The monitor will send commands targeted to that app’s channel, which the server routes appropriately.
    
-   **`respond` channel:** In older implementations, the monitor subscribed to a `"respond"` channel to receive a stream of messages from all clients. In the current setup, however, the monitor’s subscription is managed via the login handshake (after logging in as master, it might receive all `"log"` events or subscribe per client channel). The naming can vary with implementation, but conceptually, the monitor gets a feed of all client events.
    
-   **Message flow:** In normal operation, **App → Server → Monitor:** the app emits events (actions/state) on `"log"`; the server receives and publishes these to the monitor (either on a common channel or by emitting directly, since the monitor is the authenticated master). **Monitor → Server → App:** when the user uses the DevTools UI (e.g. dispatches an action or navigates state history), the monitor sends a command (like `"DISPATCH"` or `"IMPORT"`) on the app’s specific channel; the server receives it and forwards it to that particular app client.
    

_Diagram:_ On a high level, imagine the app and monitor both connected to the server. The app sends up a stream of events (actions/state) tagged with its instance ID. The monitor listens to all streams (or a combined stream) and displays them. When the monitor needs to control the app (e.g., jump to a state), it sends a message addressed to that app’s ID. The server brokers this exchange. (See the message types below for details on specific events.)

**DevTools Message Types and Schema**  
During a debugging session, the app and monitor exchange JSON messages of various types. Each message has a `type` field (string) and additional fields depending on the message. All complex data (like state trees or actions that may include non-serializable values) is encoded as JSON using **JSAN** – a serializer that supports functions, Symbols, circular references, etc., by encoding them to a special JSON representation. The receiving side must parse the data with the same library to restore it. Below is a catalog of important message types in the protocol and their roles:

-   **`START`** – Indicates the beginning of a devtools session. Typically sent by the app **to the monitor** right after a successful connection/login. It informs the monitor that the app is ready to send data. In practice, the Redux DevTools enhancer sends `START` once the socket handshake is done[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=this.started%20%3D%20true%3B%20this.relay%28%27START%27%29%3B%20). The monitor, upon receiving this, knows it can expect state/action updates. (The monitor itself might also send a `START` to the app as part of handshake; see Roles below.) This message may include an `instanceId` or other identification if needed (often the server socket ID or a custom instance name).
    
-   **`STOP`** – Indicates the end of a session. Sent by the app when it is about to disconnect or stop sending updates. The monitor or server may also emit a `STOP` (or a `DISCONNECTED`) if the app connection is lost. Upon receiving `STOP`, the monitor should consider the session closed. The app’s internal enhancer will set its `isMonitored` flag to false and stop transmitting when a stop/disconnect occurs[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,type%20%3D%3D%3D%20%27ACTION%27%29).
    
-   **`ACTION`** – Represents a single Redux action that was dispatched in the app, along with the resulting state (or state diff). This is sent by the app **to the monitor** for each Redux action (unless filtered out by filters). An ACTION message typically contains:
    
    -   `action`: The action object that was dispatched (serialized via JSAN if not a plain object). Often this is wrapped as `{ type: "PERFORM_ACTION", action: {…original action…}, timestamp: ... }` in the lifted state structure, but over the wire it may just include the user’s action or a summary.
        
    -   `payload` (or `state`): The new state after the action. Sometimes only the changed parts are sent (as in diff mode), but often it’s the entire state or the portion allowed by any state sanitizers.
        
    -   `nextActionId`: A sequential ID number for this action in the timeline (e.g., 1 for the first action, 2 for the second, etc.).
        
    -   `instanceId`: An identifier for the app instance (to correlate messages to a specific client).
        
    -   `isExcess`: (optional) A boolean indicating if the number of stored actions has exceeded the `maxAge` limit – in which case DevTools might start dropping the oldest actions. The app’s enhancer toggles this when `stagedActionIds.length >= maxAge`[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=this,maxAge%3B).
        
    -   Other fields like `timestamp` or `trace` (if tracing is enabled) might appear if configured.
        
    
    The ACTION message allows the monitor to append a new entry in the action log and update the state preview. It is essentially a partial update: “Action X happened, and here’s the new state (or diff).” If actions are being batched (via the `latency` option), multiple actions might be sent together or in quick succession.
    
-   **`STATE`** – Represents the full **lifted state** of the Redux store (the entire history of the app’s state/actions as managed by the DevTools instrumentation). This is usually sent by the app to the monitor upon initial connection or upon certain requests. A STATE message contains the whole debugging state: all actions by ID, the current state index, etc. In JSON, it includes keys like `actionsById`, `computedStates`, `currentStateIndex`, `nextActionId`, `paused`/`locked` flags, etc. Because this can be quite large, it’s typically sent only when needed (for example, on startup or after a time-travel command). The structure corresponds to the internal lifted store of the DevTools (explained in the next section). For example, when a monitor first connects, the app might send a STATE message like:
    
    ```
    <div><p>json</p><p><code id="code-lang-json"><span><span><span>{</span></span><span>
      </span><span><span>"type"</span></span><span><span>:</span></span><span> </span><span><span>"STATE"</span></span><span><span>,</span></span><span>
      </span><span><span>"id"</span></span><span><span>:</span></span><span> </span><span><span>"&lt;instanceId&gt;"</span></span><span><span>,</span></span><span>
      </span><span><span>"name"</span></span><span><span>:</span></span><span> </span><span><span>"&lt;app display name&gt;"</span></span><span><span>,</span></span><span>
      </span><span><span>"payload"</span></span><span><span>:</span></span><span> </span><span><span>"{"</span></span><span>actionsById</span><span><span>":{...}, "</span></span><span>computedStates</span><span><span>": [...], ...}"</span></span><span> 
    </span><span><span>}</span></span><span>
    </span></span></code></p></div>
    ```
    
    Here, `payload` is a JSAN-stringified lifted state object[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=%27content,getLiftedState%28%29%29%2C). The `id` and `name` help identify the session (the name often being what’s shown in the DevTools UI for that app, e.g. the app name or host). The monitor uses the STATE data to populate the entire dev timeline (so you can see past actions, etc.); it’s essentially a snapshot of the entire debugging session state.
    
-   **`DISPATCH`** – A command from the monitor to the app to manipulate the state history or dispatch a monitor action. These are not Redux actions from the app, but DevTools actions like “time-travel to state”, “reset”, “commit”, or even “perform a jump”. The `DISPATCH` message usually has an `action` field which describes the dev command. For example, when you click the “Jump to action #5” in the DevTools, the monitor sends `{ type: "DISPATCH", action: { type: "JUMP_TO_ACTION", actionId: 5 } }`. The app’s DevTools enhancer will interpret this and adjust the lifted state (e.g., update the `currentStateIndex`) accordingly[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,%2F%2F%20Prevent%20flooding). Other possible dispatch commands include `JUMP_TO_STATE`, `RESET` (to wipe history), `COMMIT` (to squash history up to current state), `ROLLBACK` (to revert to the state when DevTools opened), `PAUSE_RECORDING` (toggles whether to record new actions), etc. The app should handle each appropriately by dispatching the corresponding action to its internal lifted store (the code indeed calls `store.liftedStore.dispatch(message.action)` for DISPATCH messages[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,this.store.liftedStore.dispatch%28message.action%29%3B)).
    
-   **`ACTION` (Monitor-to-App)** – _Do not confuse this with the app-to-monitor ACTION message._ If the monitor UI’s dispatcher is used (where you can manually dispatch an action via the DevTools), the monitor can send an `ACTION` message to the app. In this context, the `ACTION` message (coming _from monitor to app_) carries an `action` object that the user wants to dispatch in the app. The DevTools enhancer on the app will receive `message.type === "ACTION"` and then call `dispatchRemotely(message.action)` to dispatch that action into the app’s Redux store[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,%2F%2F%20Prevent%20flooding). This allows developers to dispatch test actions from the DevTools UI remotely. The distinction is: an app-originated ACTION means “this just happened in the app,” whereas a monitor-originated ACTION means “please dispatch this in the app.”
    
-   **`SYNC`** – A request from the monitor for the app to resend its current state (and history). This might be used when a new monitor connects to an already running app, or if the monitor lost some messages and needs to resynchronize. The monitor sends `SYNC`, possibly including an `id` or some identifier. In the enhancer code, we see that if a SYNC comes in and it’s for a different socket (`message.id !== this.socket.id`), the app interprets it similarly to an import[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=message.type%20%3D%3D%3D%20%27IMPORT%27%20,type%3A%20%27IMPORT_STATE). In common usage, upon receiving `SYNC`, the app likely responds by sending a fresh `STATE` message (full lifted state) to the monitor. In some implementations, SYNC could carry a snapshot of state to directly import on the client, but typically it’s a simple request. The server or monitor might use SYNC after reconnections.
    
-   **`IMPORT`** – A message used to import a state history into the app. This is typically triggered when a user drags-and-drops a JSON of a previous session or selects a report to load. The monitor sends an `IMPORT` message with a payload (often a large serialized lifted state). The app, upon receiving `message.type === "IMPORT"`, will parse the provided state and dispatch an `IMPORT_STATE` action internally to replace its current lifted state with the one from the message[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=message.type%20%3D%3D%3D%20%27IMPORT%27%20,type%3A%20%27IMPORT_STATE). In effect, this loads the entire timeline from the imported data – allowing the developer to inspect or continue from that state history. The `IMPORT` message and the `SYNC` message are handled similarly in the code, merging the provided state if it’s not the same instance, as shown in the enhancer’s `handleMessages` logic[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=message.type%20%3D%3D%3D%20%27IMPORT%27%20,type%3A%20%27IMPORT_STATE).
    
-   **`UPDATE`** – A ping from the monitor to request an update from the app, often in response to the monitor subscribing. In the code, when `message.type === "UPDATE"`, the app simply calls `relay('STATE', currentLiftedState)` to send the latest state back to the monitor[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,message.type%20%3D%3D%3D%20%27DISCONNECTED). Essentially, if the monitor wants to force a refresh of the app state (for example, if the UI was reloaded), it can send `UPDATE` and the app will respond with its current full state. The `UPDATE` message might also be used by the monitor to tell a newly connected app who the monitor is (though in the current protocol, `START`/`STOP` cover most of that handshake).
    
-   **`ERROR`** – Used to relay error messages. If the app encounters an error (for example, an exception in a reducer), the enhancer may catch it and send an `ERROR` message with details. Likewise, the monitor might send an `ERROR` if it failed to parse or apply something. In practice, the Redux DevTools will display errors in the monitor (for instance, if you have an error, you might see a red notification in the DevTools). The `error` message typically has a `payload` that is a string or JSAN stringified error. There is also an `error` method in the DevTools API for sending custom errors[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=%2A%20send%28action%2C%20state%29%20,we%20can%20just%20use%20the).
    
-   **`DISCONNECTED`** – A notice that the connection was lost. This might be sent by the server to the monitor when an app client disconnects unexpectedly (so the monitor can mark that instance as gone). The app’s enhancer also treats `DISCONNECTED` similar to `STOP` (turning off monitoring)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,type%20%3D%3D%3D%20%27ACTION%27%29). Essentially, it’s a synthetic STOP. Not all implementations send a distinct DISCONNECTED message; some just rely on the WebSocket close event.
    

Each message going over the wire is typically a small JSON object containing at least a `type` field and additional keys as described. All state data in these messages (like the `payload` of a STATE or the actions in an ACTION message) are serialized with **JSAN** to preserve data fidelity (e.g., preserving undefined, Symbol, or other non-JSON values)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=type%3A%20%27STATE%27%2C%20id%3A%20this,getLiftedState%28%29%29%2C). This means an implementer should use the same JSAN library (or compatible logic) to serialize/deserialize the payloads. In JavaScript, `jsan.stringify()` and `jsan.parse()` are used by the DevTools enhancer[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=type%3A%20%27STATE%27%2C%20id%3A%20this,catch%20%28err%29)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=%29%20).

**The Lifted State Model (Time-Travel State)**  
To understand messages like STATE, ACTION, and how time-travel works, it’s crucial to grasp the concept of **lifted state**. The “lifted” state is the state of the Redux store as observed by the DevTools, which includes not just the current app state but the history of actions and states. When Redux DevTools instrumentation is applied to a store (via `composeWithDevTools` or the enhancer), the store is wrapped in a “monitor” reducer that manages this lifted state. Key components of the lifted state include:

-   **`actionsById`** – an object mapping each action ID (starting from 0 or 1) to an action descriptor. Each entry typically has `{ action: {...}, timestamp: ..., stack: ... }`. The very first action (ID 0) is usually the INIT action (`@@INIT` or similar). Subsequent actions are of type `PERFORM_ACTION` containing the user-dispatched action. If actions are sanitized or filtered, that will reflect here (e.g., certain actions might not appear if filtered out).
    
-   **`computedStates`** – an array of state objects corresponding to each action in the timeline. `computedStates[i]` is the app state after applying action with ID i (and all prior actions). Index 0 is the initial state. This array grows with each new action, unless actions are dropped due to maxAge limits.
    
-   **`currentStateIndex`** – an index pointer (integer) indicating which computedState is currently considered “active” or shown. Normally this points to the last action (the latest state), but if the user has time-traveled to an earlier state, `currentStateIndex` will point to that entry, and the app’s Redux store state is rolled back to that point. The DevTools UI uses this to highlight the selected action.
    
-   **`stagedActionIds`** – an array of all action IDs that are in the current timeline. This is usually `[0, 1, 2, ... nextActionId-1]` unless some actions were removed. If you “sweep” (delete) actions or if you have filtered out actions, this array represents the IDs that are still considered. The order of this array is the order of actions in time.
    
-   **`nextActionId`** – the next ID to assign to a new action. Essentially equals the length of stagedActionIds (since IDs are zero-based or one-based depending on implementation, nextActionId may be stagedActionIds.length in a zero-based scheme).
    
-   **`skippedActionIds`** – an array of action IDs that are currently toggled off (skipped). DevTools allows you to skip (disable) actions, meaning they are removed from the computation temporarily. If an ID is in this list, the corresponding action is not applied to produce future states (the computedStates array will reflect the state with that action skipped). This is how you can toggle certain actions on/off in the log.
    
-   **`committedState`** – if you “commit” the state (which resets the history but keeps the current state as the new base), that committed point’s state is stored here. Committing clears the earlier history; the DevTools will empty actions before that point and consider this state as the new initial state (action 0). If no commit has been done, committedState may be null/undefined.
    
-   **`isLocked` / `isPaused`** – booleans indicating if the DevTools is in a locked or paused state. _Locking_ means the DevTools is not currently recording new actions (used when you want to temporarily stop recording, e.g., to prevent devtools from interfering with certain interactions). _Pausing_ is similar (pausing recording when an error is caught, for example). When `isLocked` is true, the enhancer will not pass actions to the DevTools (so the timeline freezes). When `isPaused` is true, new actions are queued internally but not recorded until unpaused. The monitor toggles these via specific DISPATCH commands (`LOCK_CHANGES`, `PAUSE_RECORDING`), which the app’s enhancer handles (we see in code that on receiving such commands, the enhancer sets flags and stops relaying actions until unlocked[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=return%3B%20,this.locked%29)).
    

All these fields together form the **lifted state object**. This object is what gets serialized and sent in a `STATE` message to represent the full debugging session. It’s also what gets saved if you export or save a debug session (report). By examining `actionsById` and `computedStates`, a developer can reconstruct what happened in the app.

**Time-Travel and State Manipulation:** The lifted state model enables time-travel debugging. When a monitor instructs a jump to an earlier state (say action ID 5), the DevTools enhancer intercepts that command (`JUMP_TO_ACTION`) and sets `currentStateIndex = 5`. It then resets the app’s Redux state to `computedStates[5]`. From that point, the app appears as it was after action 5. The timeline UI in the monitor will highlight action 5. If the user then dispatches a new action while time-travelled, the DevTools may either replace the future actions or treat it as a new branching (by default, future actions are lost when you time-travel and then dispatch). Similarly, `JUMP_TO_STATE` might jump to an arbitrary state index (slight difference: `JUMP_TO_ACTION` typically by actionId, `JUMP_TO_STATE` by state index — in practice they are often the same since each action has a state, but one might include the initial state as index 0 whereas an actionId might start from 1).

Other commands like `RESET` will wipe the slate: it clears the history (resets lifted state to just the current state as the initial state). `COMMIT` will take the current state and remove all earlier actions (i.e., set committedState to current, and clear history). `ROLLBACK` will revert the app state to committedState and clear the staged actions since the last commit. When these happen, the structure of lifted state changes (actionsById might be pruned, etc.), and the monitor receives an updated STATE to reflect the new history.

**Import/Export:** The lifted state can be exported to a JSON (the DevTools UI’s “Export” feature basically serializes the lifted state via JSAN). Conversely, “Import” takes such a JSON and sends it as an `IMPORT` message. The app’s enhancer will replace its current lifted state with the imported one, thus loading all those actions and states as if they had been replayed. This is how you can save a debug session and reload it later. When an import happens, the app will usually emit a fresh `STATE` message (or a series of `ACTION` messages) to sync the monitor with the new timeline.

In summary, the lifted state is a comprehensive record of the app’s execution history for debugging purposes. The remote DevTools protocol revolves around syncing and manipulating this lifted state between the app and the monitor.

**Roles and Communication Flow**  
There are three main actors in the remote DevTools architecture: the **application client**, the **DevTools monitor**, and the **DevTools server** (SocketCluster server). Each plays a distinct role:

-   **Application Client (App)**: This is the running application instrumented with the DevTools enhancer. Its responsibilities:
    
    -   Connect to the WebSocket server (usually at startup). If using the `devToolsEnhancer`, this connection is established automatically. The app may attempt to connect repeatedly until successful (SocketCluster client has built-in reconnect).
        
    -   After connecting, perform the handshake (`login`). The app might not send any special login payload (or in some implementations it could send an instance name or nothing at all). The server will respond with a channel (like a unique socket ID) for further communication[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=login%28%29%20,break). The app subscribes to that channel for incoming messages.
        
    -   Start sending an initial burst of data: The app immediately sends a `START` message (to indicate it’s online) and likely a full `STATE` or at least the current state, so the monitor can populate. In the code, once the app’s DevTools enhancer `login()` completes, it calls `this.relay('START')` and then will also send the current state[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=this.started%20%3D%20true%3B%20this.relay%28%27START%27%29%3B%20)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=this.relay%28%27STATE%27%2C%20this.getLiftedState%28%29%29%3B%20,type%20%3D%3D%3D%20%27DISCONNECTED%27%29).
        
    -   On every Redux action: send an `ACTION` message with the details of that action and the new state (unless recording is paused/locked). This is done via the enhancer automatically on each dispatch that isn’t filtered. We saw that if the last action is a normal dispatch, it calls `relay('ACTION', ...)` with the relevant data[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=if%20%28this.lastAction%20%3D%3D%3D%20%27PERFORM_ACTION%27%29%20,maxAge). These messages stream out in real-time so the monitor log updates. If the DevTools is paused/locked, the app may hold off sending until resumed (ensuring not to record actions that occur while paused).
        
    -   Handle incoming monitor messages: The app listens on its private channel for any messages from the monitor. According to the enhancer’s `handleMessages` function, the app will respond to different message types accordingly[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=message.type%20%3D%3D%3D%20%27IMPORT%27%20,type%3A%20%27IMPORT_STATE)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,type%20%3D%3D%3D%20%27DISCONNECTED%27%29)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,%2F%2F%20Prevent%20flooding). For example:
        
        -   On `START`: the app knows a monitor is now actively listening, so it might set a flag and immediately send a fresh `STATE` (which includes all actions and the current state)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=this.relay%28%27STATE%27%2C%20this.getLiftedState%28%29%29%3B%20,type%20%3D%3D%3D%20%27DISCONNECTED%27%29).
            
        -   On `STOP` or `DISCONNECTED`: the app knows the monitor went away; it might set `isMonitored=false` and stop sending further `ACTION` updates until a new monitor connects[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,type%20%3D%3D%3D%20%27ACTION%27%29).
            
        -   On `DISPATCH` (time-travel or other command): the app dispatches that special action to its lifted store (e.g., perform the jump or commit). The result is a new lifted state, and likely an updated `STATE` message back out to reflect the changes.
            
        -   On `ACTION` (from monitor): the app will dispatch that provided action into the actual Redux store (this is done via `dispatchRemotely`)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,%2F%2F%20Prevent%20flooding). Any state change from that will in turn trigger the normal flow of sending an ACTION message from the app as well.
            
        -   On `IMPORT`: the app will load the provided state into the DevTools (replacing its lifted state) and then emit a new `STATE` to sync.
            
        -   On `SYNC`: the app may simply re-emit the current `STATE` (or handle it like an import if a state was attached).
            
    -   Maintain its connection: The app’s enhancer will try to reconnect if the socket drops, and typically will re-authenticate and resend the whole state on re-connection so the monitor can continue.
        
    
    From the app’s perspective, it doesn’t know who the monitor is; it just knows that some consumer might be there. It keeps the server informed of its latest state, whether or not a monitor is currently connected. (If no monitor is connected, the server might not do anything with the logs, though it could buffer them if configured to save logs.)
    
-   **DevTools Monitor (UI)**: This is typically either the Redux DevTools browser extension (in remote mode), the Redux DevTools CLI (which opens a browser UI), or another tool that acts as the debug UI. Its responsibilities:
    
    -   Connect to the DevTools server as a **master**. The monitor will invoke `login` with `"master"` as the key[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=3,Channel%20of%20Events). The server recognizes this and usually assigns the monitor a special role or channel. In practice, there might be multiple monitors, but generally one master at a time is assumed. After login, the monitor subscribes to the appropriate channel(s) to receive events. Depending on the server, the monitor could subscribe to a global `"respond"` channel or it might simply rely on being a special client that gets copies of all `"log"` messages.
        
    -   Receive events from all connected apps. The monitor typically shows a list of instances (each app has an instance name or ID). For each connected app, it will receive that app’s `START` message, at which point it can display the new instance in the UI. Then as the app sends `ACTION` or `STATE` messages, the monitor updates the UI accordingly (populating the list of actions, updating state diff, etc.). If multiple apps connect, it segregates them by instanceId (often shown in a dropdown or list in the monitor UI).
        
    -   Request or initiate sync: If the monitor connects to an app that’s already running, it may send a `START` or `SYNC` message to prompt the app to send the current state. In some implementations, simply subscribing as master triggers the server to instruct all clients to send a fresh `STATE`. In others, the monitor explicitly emits something (the extension might emit a `START` to each instance). The end result is the app will send its state so the monitor can catch up.
        
    -   Send control commands: When the user uses the DevTools UI controls, the monitor sends messages back to the app:
        
        -   When time-traveling (jumping to an earlier action or toggling skip on an action), the monitor sends a `DISPATCH` message with the appropriate payload (e.g., `{ type: 'JUMP_TO_ACTION', actionId: X }` or `{ type: 'TOGGLE_ACTION', id: X }`).
            
        -   When the user dispatches an action via the UI (using the dispatcher or importing a custom action), the monitor sends an `ACTION` message containing that action.
            
        -   Hitting the pause button sends a dispatch like `{ type: 'PAUSE_RECORDING' }`. Committing, rolling back, etc., likewise send specific dispatches. All these are encapsulated as `DISPATCH` messages (except the raw action dispatch, which uses `ACTION`).
            
        -   If the user selects “Import” and provides a JSON, the monitor sends an `IMPORT` message with the JSON string (or a reference) as `state`. Similarly, if the monitor wants a fresh copy of state without changing anything, it might send `SYNC` or `UPDATE`.
            
    -   The monitor does not directly talk to the app except through the server’s channels. When it sends a command, it usually includes the target instance’s ID so the server knows where to route it (the server might in fact provide separate channels per instance as mentioned). In the case of the extension, it often knows the instanceId (the instanceId is included in messages from the app, and the extension picks it up). For the CLI monitor, the UI shows a list of instances and when you select one, your commands go to that instance’s channel.
        
    -   If the monitor disconnects (e.g., user closes the DevTools window or the CLI UI), it typically sends a `STOP` (or simply disconnects, and the server then notifies the app as a `DISCONNECTED`). The app then knows to stop sending until a new monitor connects. If the monitor reconnects, it will go through login again and possibly get new channels (unless the server keeps it persistent).
        
-   **DevTools Server**: This is the SocketCluster server (for example, the `remotedev-server` NPM package or the server built into `@redux-devtools/cli`). It acts as a relay and coordinator:
    
    -   When an app client connects and calls `login`, the server generates a unique identifier (often the socket’s ID, or an `instanceId` if provided by the client). It may store some metadata like the client’s name (the app can send a name in the login, but if not, the server might use a default). The server might respond to the app’s login with a channel name like `"respond_XYZ"` or `"sc-XYZ"` (where XYZ is the socket id). The app will then subscribe to that.
        
    -   The server also registers master (monitor) connections. There could be multiple monitors or none. The server typically flags the one that logged in with `"master"` and might store it specially.
        
    -   **Routing logic:** When the server receives a message on the `"log"` channel from an app, it needs to forward that to any monitors. The official `remotedev-server` uses a convention: an app initially emits on `"log-noid"`; the server intercepts that, tags it with the socket id, and republishes it on the `"log"` channel. Monitors subscribed to `"log"` then get the message along with the instance id. In effect, monitors can listen to `"log"` to get all events from all apps[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=We%20can%20use%20log%20or,before%20the%20connection%20was%20established). The message itself will contain an `id` field (the instanceId), so the monitor knows which app it belongs to. If the monitor UI filters by a specific instance, it will just show those. In some versions, the server might use separate channels per instance and have the monitor subscribe to all of them; but the simpler approach is a unified log stream.
        
    -   When a monitor sends a message (like a dispatch) intended for an app, the server looks at the `instanceId` in that message (or the channel through which the monitor sends it) and routes it to the correct app’s channel. If using SocketCluster channels, the server might simply publish it to the target app’s private channel (which the app is subscribed to). The enhancer code suggests the monitor’s dispatch would indeed arrive in the app’s subscribed consumer loop[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=try%20,break).
        
    -   The server may also handle special events like saving reports (discussed next). Notably, the server is largely stateless for the real-time aspect: it just shuttles messages back and forth. It might maintain a list of connected clients and their names for the monitor’s instance list. In `remotedev-server`, there’s logic to handle a "report" event, login events, etc., but not much processing of the content of the messages themselves (it doesn’t need to understand Redux, it just labels and forwards JSON).
        
    -   When a client disconnects, the server will typically inform monitors. In `remotedev-server`, it broadcasts a `{ type: "DISCONNECTED", id: <instanceId> }` message on the log channel so monitors know that particular instance went away. This triggers the DevTools UI to mark it offline (and as noted, the app will also do its own cleanup on seeing this).
        

_Sequence Example:_ A typical flow might look like this:

1.  **App connects** – App invokes login, server responds with channel “xyz”. App subscribes “xyz”. App sends START on “log” (or log-noid).
    
2.  **Monitor connects** – Monitor invokes login('master'), server authenticates it as master. Monitor now listening on “log” (or similar).
    
3.  **Handshake** – Monitor might send its own START or the server might propagate app’s START. The end result: Monitor requests state, app sends STATE. Monitor displays initial state.
    
4.  **Action dispatch** – User does something in app, app’s Redux dispatch occurs. DevTools enhancer catches it, forms an ACTION message with details, and sends it on “log”. Server forwards it, monitor receives it and updates the UI (adds the action to log, updates state diff).
    
5.  **Time travel** – User clicks on a past action in DevTools. Monitor sends a DISPATCH `{ type: 'JUMP_TO_ACTION', actionId: N }` intended for that app’s instance. Server routes it to app’s channel. App’s enhancer receives it, updates currentStateIndex = N, and sends a new STATE message reflecting that the current state is now what it was at action N. Monitor gets the STATE and updates the UI to show you’re now at that point in time.
    
6.  **Import** – User selects a previously saved debug session. The monitor fetches that session (perhaps via the server’s API) and then sends an IMPORT message with the serialized data. App receives it, replaces its lifted state, and starts treating those imported actions as its history. It then sends a fresh STATE message to sync. Monitor now shows the imported timeline.
    
7.  **Disconnect** – If app or monitor disconnects (e.g., app closes), the server will notify the other side. Monitor might receive DISCONNECTED for that instance and will stop expecting data. The app’s enhancer sees connection drop and might queue actions until reconnected. When reconnected, it will send a new START/STATE to resume.
    

These flows ensure the monitor and app stay in sync and allow full control from the monitor side.

**Persistence and Report Storage (GraphQL API)**  
One useful feature of the Redux DevTools remote setup is the ability to persist debug sessions (action history and state) on the server. The official `remotedev-server` supports saving “reports” which are essentially snapshots of the lifted state that can be loaded later or shared.

-   **Saving Reports:** A report can be created in two ways: manually by the user (using the DevTools UI “Save” button which likely triggers a special action or HTTP call), or automatically on certain events (like when an error occurs and is caught by DevTools, it might save the state). The server’s README indicates that reports are posted to the server’s root URL via HTTP[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Redux%20DevTools%20extension%20%20or,See%20examples%20in%20tests). In fact, the DevTools enhancer code has a `send()` method that can POST the lifted state to a URL (this is used when no live connection is present, e.g., using the remote devtools in “standalone” mode or when sending reports to a cloud)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=%280%2C%20_defineProperty2.default%29%28this%2C%20%27send%27%2C%20%28%29%20%3D,type%27%3A%20%27application%2Fjson%27%2C). In a typical setup with a running server, the state is already known to the server via WebSocket, but calling the save function ensures it’s written to the database.
    
-   **Database configuration:** The server is backed by a database using Knex (supporting various DBs). By default, if not configured, it uses an in-memory SQLite database[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Remotedev%20server%20is%20database%20agnostic,Here%27s%20an%20example%20for%20PostgreSQL). That means all reports are ephemeral (lost when the server stops) unless you provide a file path or a real database. You can configure this with the `--dbOptions` flag, pointing to a JSON config. For example, to persist to a file, you’d use a SQLite file path; for PostgreSQL, you’d specify client `"pg"` and connection details[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Remotedev%20server%20is%20database%20agnostic,Here%27s%20an%20example%20for%20PostgreSQL). The README provides an example config for Postgres[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=%7B%20,true). Ensure `migrate: true` is set if you want the server to run DB migrations (setting up tables).
    
-   **GraphQL Interface:** The remotedev-server exposes a GraphQL endpoint for querying and managing reports. You can navigate a browser to **`http://localhost:8000/graphiql`** (assuming default host/port) to open an interactive GraphiQL UI[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Redux%20DevTools%20extension%20%20or,See%20examples%20in%20tests). Through GraphQL, you can query stored reports, e.g., get a list of saved sessions, or fetch the details (which would include the actions and state). The exact schema isn’t fully documented in the README, but it likely has types like `Report` with fields for `id`, `title`, `createdAt`, and perhaps the JSON payload of the lifted state. The README suggests you can get “action history right in the extension just by clicking the link from a report”[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=You%20can%20store%20reports%20via,See%20examples%20in%20%20102). Typically, the workflow is: a report is saved (server returns an ID or link), and the extension can query that report’s content and then dispatch an IMPORT to load it.
    
-   **Using the Reports:** In the DevTools extension UI, saved reports might show up in a list or as a link (depending on implementation). By clicking one, the extension will retrieve the report (via GraphQL query behind the scenes) and then dispatch an IMPORT message to load it into the current monitor session. If you’re building a custom integration, you could also directly query the GraphQL API for a report and then feed that data to a DevTools client.
    
-   **GraphQL Example:** Although not explicitly given in the docs, a likely query might be:
    
    ```
    <div><p>graphql</p><p><code id="code-lang-graphql"><span><span><span>{</span></span><span>
      reports </span><span><span>{</span></span><span>
        id
        title
        createdAt
        payload  // maybe the serialized state
      </span><span><span>}</span></span><span>
    </span><span><span>}</span></span><span>
    </span></span></code></p></div>
    ```
    
    or a query by id:
    
    ```
    <div><p>graphql</p><p><code id="code-lang-graphql"><span><span><span>{</span></span><span>
      report</span><span><span>(</span></span><span><span>id</span></span><span><span>:</span></span><span> </span><span><span>"&lt;someId&gt;"</span></span><span><span>)</span></span><span> </span><span><span>{</span></span><span>
        payload
        // </span><span><span>...</span></span><span>other fields
      </span><span><span>}</span></span><span>
    </span><span><span>}</span></span><span>
    </span></span></code></p></div>
    ```
    
    The `payload` would be the saved lifted state JSON. Once obtained, you can use JSAN.parse on it and dispatch an IMPORT\_STATE action in the app.
    
-   **Posting Reports:** The README notes that reports are posted to `http://localhost:8000/` [github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Redux%20DevTools%20extension%20%20or,See%20examples%20in%20tests). This implies that when the extension saves a report, it does an HTTP POST to the server (at the root path, likely with a JSON body containing the lifted state and some metadata). The server then stores it and possibly returns a report ID. This is mostly internal to the extension’s operation, but if needed, one could mimic it by sending their own POST requests (which the server’s GraphQL or REST handler would accept).
    

In summary, the persistence feature allows long-term storage of Redux debug sessions, which is useful for bug reports or sharing state with colleagues. If you need this, ensure to configure the server with a persistent DB. If you don’t need it, the default in-memory DB is fine (or you can disable saving entirely).

**Integration Guide (Practical Setup)**  
Setting up remote Redux DevTools involves two sides: instrumenting your app, and running a DevTools monitor (and server). Here are common scenarios:

1.  **Instrumenting a Redux App (Web/Node):** If you have a Redux store in a non-browser environment (or you want to use a separate DevTools UI instead of the browser extension), install the remote DevTools enhancer. For example, using Redux Toolkit or plain createStore:
    
    ```
    <div><p>js</p><p><code id="code-lang-js"><span><span><span>import</span></span><span> { configureStore } </span><span><span>from</span></span><span> </span><span><span>'@reduxjs/toolkit'</span></span><span>;
    </span><span><span>import</span></span><span> { devToolsEnhancer } </span><span><span>from</span></span><span> </span><span><span>'@redux-devtools/remote'</span></span><span>;
    
    </span><span><span>const</span></span><span> store = </span><span><span>configureStore</span></span><span>({
      </span><span><span>reducer</span></span><span>: rootReducer,
      </span><span><span>enhancers</span></span><span>: [</span><span><span>devToolsEnhancer</span></span><span>({ </span><span><span>name</span></span><span>: </span><span><span>'MyApp'</span></span><span>, </span><span><span>hostname</span></span><span>: </span><span><span>'localhost'</span></span><span>, </span><span><span>port</span></span><span>: </span><span><span>8000</span></span><span> })]
    });
    </span></span></code></p></div>
    ```
    
    The `devToolsEnhancer` from `@redux-devtools/remote` will automatically handle connecting to the server at the given hostname/port and set up all the messaging described above. The `name` option is useful to identify your app instance in the DevTools UI (otherwise it might default to something like `document.title` or a random id). There are other options you can pass, like `realtime` (boolean, true by default, meaning it streams actions in real time) and `secure` (for wss/https). In a React Native context, you might use `configureStore` similarly or the older `applyMiddleware(devToolsEnhancer())` style for classic Redux.
    
    If you prefer not to include the enhancer in production code, you can conditionally apply it in development. However, note that remote devtools can be used in production for debugging if needed (just be cautious with exposing the port).
    
2.  **Starting the DevTools Server:** You have two primary choices: use the standalone CLI or use the Node module.
    
    -   **CLI method:** Install `@redux-devtools/cli` globally or as a dev dependency. Then run:
        
        ```
        <div><p>bash</p><p><code id="code-lang-bash"><span><span>npx redux-devtools --hostname=localhost --port=8000 --open
        </span></span></code></p></div>
        ```
        
        This will start a server on the specified host/port and automatically open the DevTools monitor UI in your default browser[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=2.%20Use%20%60%40redux,open). The `--open` flag launches the UI, which is a local web app for the DevTools. You can also omit `--open` and navigate to `http://localhost:8000` manually (the CLI serves the UI at the root URL). The CLI’s server is essentially the same as remotedev-server under the hood.
        
    -   **remotedev-server package:** Alternatively, you can use the older `remotedev-server` package. For example, you can add a script in your project’s package.json: `"remotedev": "remotedev --hostname=localhost --port=8000"` and run `npm run remotedev`[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=,json). This achieves the same effect (starting the server). The CLI method is basically a wrapper around this, and the Redux DevTools extension’s remote feature can connect to this server.
        
    -   **In-code integration:** If you already have a Node.js server for your app, you can also integrate the devtools server into it by requiring `remotedev-server` in code and calling `remotedev(options)` to start it within your process[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=,for%20starting%20a%20development%20server). This might be useful for React Native (where you can start it along with Metro bundler) or for bundling in an electron app.
        
3.  **Launching the Monitor UI:** If you used `redux-devtools --open`, the UI is already open in your browser. If not, you can open a browser to `http://localhost:8000` (or wherever your server is running) to see the UI. The monitor UI will list any connected app instances by their name. If nothing shows up, check the app logs to ensure it connected successfully, and check the server terminal for any messages (e.g., it usually logs connections).
    
    -   **Using the Browser Extension:** Alternatively, you can use the standard Redux DevTools browser extension in a special mode. In the extension’s settings, there is an option to specify a remotedev server (host/port). If you point that to your remotedev-server, the extension will connect as a monitor. In practice, this method is less common now that the CLI exists, but it’s useful if you prefer the extension UI. Note that if you use the extension, you might not need to run the separate UI, but you still need the server if the app is not in the same browser context.
        
    -   **Multiple monitors:** You can actually have the CLI UI and the browser extension, or multiple CLI UIs, connect to the same server. They should all receive the same events (the server will send app logs to all masters). However, having two monitors both controlling the same app can lead to conflicting commands (e.g., two people time-traveling one app at once). It’s mainly intended for one monitor at a time.
        
4.  **React Native specifics:** If debugging a React Native app, `@redux-devtools/remote` works since RN can use websockets. One catch is that your device/emulator must reach the host machine. The default `hostname: 'localhost'` works for emulators on the same machine (Android emulator remaps localhost to the host machine via `10.0.2.2` usually). The DevTools library tries to detect the host (there’s often logic to use `rn-host-detect` to pick the right IP). If you have issues, you might need to specify the LAN IP of your dev machine as the hostname so the device can connect over WiFi. Another option is the `--injectserver` approach in remotedev-server, which can automatically inject a script tag in the RN packager to start the server (beyond scope here, but the README mentions an `--injectserver=reactnative` option[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Inject%20to%20React%20Native%20local,server)). Also, on Android device, you can run `adb reverse tcp:8000 tcp:8000` to forward the port[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=If%20you%27re%20running%20an%20Android,the%20device%20to%20your%20computer), so that the device can use `localhost:8000`. On iOS simulator, `localhost` from the app will refer to your Mac so it should just work.
    
5.  **Verifying the Connection:** Once the app and server and monitor are all running, you should see in the monitor UI the name of your app (e.g., “MyApp” if you set the name, or some default like “ReactNativeApp” or a random ID). If you dispatch some Redux actions in the app (e.g., by interacting with it), you should see them appear in the DevTools action list in real-time. You can then try time-travel: click on a past action, and you should see the app state revert in the app (and UI reflect it). If that works, congrats – you have remote DevTools running!
    
6.  **Using DevTools Features:** Through the remote monitor, you can dispatch actions (open the DevTools UI’s dispatch panel and send an action – it will run in your app), import/export state (the export will prompt download of a JSON file; import will let you select a file or paste JSON), etc. All features of the DevTools extension (like sliders, skipping actions, etc.) should work, since the protocol supports them.
    

**Version Compatibility and Notes**  
The Redux DevTools remote protocol has been quite stable, but there are a few version considerations:

-   **Packages:** Ensure your versions are aligned. `@redux-devtools/remote` (the client enhancer) should ideally match the `@redux-devtools/cli` version. For instance, as of 2025, @redux-devtools/remote 0.8+ and @redux-devtools/cli 1.0+ work together. Older packages like `remote-redux-devtools` (a predecessor) are deprecated, though they used a similar protocol. It’s recommended to use the official Redux DevTools packages under the `@redux-devtools` scope for full compatibility.
    
-   **Remotedev-Server vs CLI:** The NPM package `remotedev-server` (by Zalmoxisus) was the original server implementation. The newer `@redux-devtools/cli` includes its own server and UI and is maintained by the Redux team. They are largely compatible in protocol. If you have issues with one, try the other. The CLI might have slight improvements (for example, it bundles an updated UI). The protocol events (log, respond, etc.) remain the same. The CLI’s server also supports the GraphQL API and saving reports just like remotedev-server did.
    
-   **`log-noid` usage:** In very old versions of the protocol, clients always emitted on a single channel and the server deduced the socket. Now, the recommended approach (and enforced in recent `@redux-devtools/remote`) is to use the socket’s built-in ID. The Scaler documentation confirms that both “log” and “log-noid” exist for compatibility[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=We%20can%20use%20log%20or,before%20the%20connection%20was%20established). For most new implementations, you can simply use the provided enhancer which handles it. If implementing from scratch, consider emitting an initial message without id (or explicitly include your own instanceId) – but since the server will attach one, it’s simpler to just follow the established pattern.
    
-   **Multiple Instances:** If you run multiple instances of your app (say two different apps or two instances of the same app), they can both connect to the same server. Each will get a distinct instanceId. The monitor will list them separately. This is supported as long as each app uses a unique `name` or at least the unique socket id. The protocol can handle many apps broadcasting to one monitor (useful for microservices or comparing app states). No special configuration needed beyond connecting them to the same server.
    
-   **Upstream Changes:** Keep an eye on the Redux DevTools GitHub for any protocol changes. As of the latest versions, the core events (STATE, ACTION, etc.) have not changed. One known change was the fix for React Native Hermes compatibility (Issue #1382) which involved tweaking how the async iterator was used in the enhancer – but that doesn’t change the protocol itself, just the internal implementation. The comment in StackOverflow indicates this was fixed in @redux-devtools/remote 0.8.0[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=login%28%29%20,next%28%29%3B%20if%20%28done%29)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=%2F%2F%20for%20await%20,catch%20%28error%29) (which moved from a `for await` loop to an explicit consumer loop for subscription, due to Hermes engine bug). This is an example of internal change that doesn’t affect the message format.
    
-   **Legacy monitor:** There was an older Electron app called “Remote Redux DevTools” (remotedev-app). It also connects to remotedev-server. If you happen to use it, it should still work, but the CLI has largely replaced it. The protocol is the same, but the UI might be outdated.
    
-   **Security:** The protocol by default has no authentication beyond the “master” keyword for monitors. In other words, if someone knows your server address and port, they could potentially connect and see your app state or dispatch actions. If you expose remotedev-server over a network (especially with `--hostname=0.0.0.0` to allow external connections), be aware of this. For secure usage, either run it locally/internally only or use an HTTPS/WSS setup with some authentication at a higher level (SocketCluster supports middleware to check an auth token on login, which you could implement). At minimum, if you need to run it in production or a shared environment, consider enabling secure protocol (`--protocol=https` with certs)[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=To%20use%20WSS%2C%20set%20,arguments) so that communications are encrypted, and potentially modify the server to verify clients. This is beyond the default, but worth noting.
    
-   **Performance:** The DevTools will send the entire state tree frequently. If your state is huge, consider using the `stateSanitizer` or `actionSanitizer` options (functions that filter or truncate the data) to avoid flooding the network or the UI with enormous payloads. You can also raise the `latency` to buffer actions. The `maxAge` (default 50) can be tweaked if you need more history, but be mindful that large history means large liftedState to sync.
    

In general, the latest versions of all official tools work well together out-of-the-box. Follow the official documentation when possible (for example, the Redux DevTools repository’s **Remote Monitoring** docs cover connecting to the server, emitting login, using log/log-noid, etc. which we cited above[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=3,Channel%20of%20Events)[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=We%20can%20use%20log%20or,before%20the%20connection%20was%20established)). This guide is based on those and on reading the source code of the tools to provide an accurate picture.

**Testing and Troubleshooting**  
Setting up the remote DevTools can involve multiple pieces, so issues can arise. Here are some common problems and ways to troubleshoot:

-   **Cannot connect (monitor shows “No connection” or app logs show socket errors):**
    
    -   Verify the **host and port** on both sides. The app enhancer must point to the correct `hostname` (and `port`). By default, `devToolsEnhancer` uses localhost:8000. If your server is on a different machine or container, you need to provide the correct host (e.g., LAN IP or hostname). In React Native on device, `hostname: 'localhost'` won’t work (since it refers to the device itself) – you’d use your dev machine’s IP or use the `adb reverse` trick for Android[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=If%20you%27re%20running%20an%20Android,the%20device%20to%20your%20computer).
        
    -   Check that the server is actually running and listening. The CLI will log to console “SocketCluster started on port 8000” or similar. If it’s not running, obviously no connection.
        
    -   Firewalls can block WebSocket connections. If connecting across networks, ensure port 8000 is open.
        
    -   If using `secure: true` (wss), make sure you provided the cert and key correctly to the server (`--key` and `--cert` options)[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=To%20use%20WSS%2C%20set%20,arguments), and that your app enhancer has `secure: true`.
        
    -   In the browser devtools (for the monitor UI), you can check the network panel for the WebSocket connection. If it’s failing, you might see error messages. One known error is if the server is only accepting secure connections but you tried ws:// (or vice versa).
        
-   **App not appearing in monitor:** The app might connect but not identify itself properly. Ensure that after connection, the app sends the `login` event. If you wrote a custom client, you must invoke `login` on the socket; otherwise the server won’t assign a channel. The official enhancer does this automatically. If the app connects but doesn’t send data, perhaps the enhancer wasn’t applied to the store (double-check your store configuration – you should see some log like “connected to remotedev” in the console if using the enhancer, or you can add a listener on the socket’s `connect` event to log it).  
    Also, if the monitor connected after the app already sent some data, you might have missed the initial START. Usually the monitor will send an `UPDATE` to ask for state – but if that didn’t happen, you could end up with an app that thinks it’s not monitored. To resolve, try refreshing the monitor UI; the extension/CLI often send a START on refresh that triggers the app to resend state.
    
-   **No actions showing / state not updating:** If the app appears in the monitor but you don’t see any actions when you perform them, possible causes:
    
    -   The app might have been locked or paused. Check if the DevTools UI indicates “Paused” or “Locked” (there are small indicators or the buttons themselves). If so, unlock or unpause. It could be that you accidentally left it paused (or some code called `devToolsExtension.pause()` programmatically).
        
    -   Your `filters` might be excluding the actions. The devTools enhancer supports filtering actions by regex (to ignore certain actions). If configured, it might be dropping them. Check if you passed any `actionsBlacklist`/`actionsWhitelist` or the newer `actionsDenylist`/`actionsAllowlist` options. If so, try removing those filters to see all actions.
        
    -   If you are using Redux Toolkit’s `configureStore` with `devTools: true` **and** also adding `devToolsEnhancer` in enhancers, you might be double-wrapping or conflicting. Generally, for remote, you should **not** enable the built-in devTools option (which is for local extension) and instead only use `devToolsEnhancer`. Having both could cause only local devtools to connect or just confusion. Set `devTools: false` if you use the enhancer explicitly.
        
    -   Check the browser console (or React Native console) for any errors. Sometimes serialization issues (e.g., a circular reference in state not handled by JSAN) could throw an error in the enhancer and stop sending. The enhancer tries to catch errors and send them, but in some cases, you might see a console error about failing to stringify. If so, consider providing a sanitizer function for that part of the state.
        
    -   If using React Native, ensure you patched known issues (like the Hermes for-await bug which was fixed in newer versions). An outdated `@redux-devtools/remote` might silently fail to function under certain engines.
        
-   **Time-travel commands not working:** You dispatch a jump or toggle in the monitor but nothing happens in the app. Possible reasons:
    
    -   The app might not be listening on the correct channel. If you wrote a custom client, ensure you subscribed to the channel returned by login. If that step is missed, the app will never receive the monitor’s messages. In the official enhancer, after `channelName = await socket.invoke('login', 'master')`, they do `socket.subscribe(channelName)` and then loop to handle messages[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=login%28%29%20,break). Without subscription, you only have one-way communication.
        
    -   The monitor might be sending to the wrong instance. If multiple instances, make sure you selected the correct one in the UI. Or if you built a custom monitor, verify it’s targeting the right channel/instanceId.
        
    -   If you see the messages arriving but the app state doesn’t change, maybe the app’s DevTools enhancer wasn’t properly integrated with the store’s reducer. E.g., in older setups, you had to instrument the store with DevTools compose; with Redux Toolkit, using the enhancer should cover it. If someone attempted a manual integration, they might have missed wrapping the root reducer with the DevTools instrument reducer. Using the official enhancer avoids that complexity by doing it internally.
        
    -   Ensure that the store is not configured with `devTools: false` inadvertently, or that you didn’t apply the enhancer in the wrong order. The enhancer must be applied at creation time, before any actions dispatch (so it can catch the initial actions).
        
    -   Double-check that the actions from the monitor (like `JUMP_TO_STATE`) are indeed being dispatched to the lifted store. In the code we saw, the enhancer handles `message.type === 'DISPATCH'` by `store.liftedStore.dispatch(message.action)`[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,this.store.liftedStore.dispatch%28message.action%29%3B). If you wrote a custom handler, you need to emulate this. For example, in a custom client you might do: `if(msg.type==='DISPATCH') { liftedStore.dispatch(msg.action); }`. The liftedStore is basically the internal devtools reducer that you get if you use `redux-devtools-instrument`. Most people won’t implement this from scratch since the enhancer does it.
        
-   **Monitor UI quirks:** Sometimes the monitor UI (especially the browser extension) might not show the instance unless you toggle a dropdown. In the extension, look for a dropdown at the top (it might say something like “Socket.io” or a random ID if you didn’t name the instance). Selecting the instance will show its actions. In the CLI UI, instances appear in a sidebar if multiple. If only one, it usually auto-selects it, but just be aware of the UI. If your app name is not showing nicely, pass the `name` option as shown in the integration guide.
    
-   **Saving and Loading reports issues:** If clicking “Save” in the monitor doesn’t do anything, check the server logs to see if it received a POST. If not, perhaps the monitor is not configured to know the server URL (the extension might default to `remotedev.io` if not configured otherwise). The CLI monitor typically knows if it launched the server. Ensure you’re running the latest versions if this is crucial. If loading (importing) a report doesn’t work, it might be a CORS issue with the GraphQL endpoint or the report might not exist. You can use the GraphiQL interface at `http://localhost:8000/graphiql` [github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Redux%20DevTools%20extension%20%20or,See%20examples%20in%20tests) to run a query manually and see if the report is there. This can help isolate if it’s a server problem or the monitor’s problem.
    
-   **Verbose Logging:** The server can output logs of messages if needed. By default `--logLevel 3` (info) is set[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=,uws%29%20ws). You can increase it (levels go up to 3 only as per SocketCluster’s levels). The server might log connections and errors by default. If you need to debug the messages, sometimes adding console.logs in your app’s `handleMessages` (if you fork or wrap the enhancer) is helpful to see what’s coming in.
    
-   **Common Pitfall:** A very common mistake is forgetting to _use the enhancer_. If you configure your store with just `devTools: true` (which is for local extension) and do not include `devToolsEnhancer`, your app will not actually connect to remotedev-server. The `devTools: true` in Redux Toolkit only talks to the browser extension (or the Redux DevTools standalone if no extension). To use a custom server, you must use the enhancer from `@redux-devtools/remote`. Double check that in your code.
    

By following this guide, you should be able to get a remote Redux DevTools setup working and have a solid understanding of the protocol’s internals. The key is that the app and monitor talk through a SocketCluster pub/sub system with well-defined message types carrying the state and actions. Almost everything the DevTools UI does can be understood in terms of those message exchanges described above.

**Conclusion and Resources**  
Remote Redux DevTools allow powerful debugging for apps outside the browser. With the protocol understood, one can even implement custom clients/monitors in other languages. For further information and reference:

-   The official Redux DevTools documentation’s section on _Remote Monitoring_ provides a concise overview of connecting to a remotedev server[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=3,Channel%20of%20Events)[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=We%20can%20use%20log%20or,before%20the%20connection%20was%20established).
    
-   The README of the `remotedev-server` (and the Redux DevTools CLI) is useful for server setup and options[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Save%20reports%20and%20logs)[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Remotedev%20server%20is%20database%20agnostic,Here%27s%20an%20example%20for%20PostgreSQL).
    
-   The source code of `@redux-devtools/remote` (in the Redux DevTools GitHub monorepo) is the ultimate reference for how the enhancer works; relevant parts of it were cited in this guide to explain message handling.
    
-   If building your own integration, the **redux-devtools-utils** and **redux-devtools-instrument** packages (also part of the Redux DevTools suite) contain utilities for serializing/deserializing state and the reducer that produces the lifted state.
    
-   Community examples: there are blogs and StackOverflow answers (some cited here) that show how to set up remote devtools in React Native and other scenarios. These can be helpful if you run into platform-specific hiccups.
    

With this information, engineers should be able to confidently integrate or implement Redux DevTools remote debugging, ensuring they can visualize and control their app state in real time even when the app isn’t running in a web browser. Debugging complex state interactions in production or on devices becomes much easier with this tool at your disposal. Happy debugging!

**Sources:** The above guide was compiled from official Redux DevTools documentation, the remotedev-server README, and relevant code snippets from the Redux DevTools repository and community knowledge. Key reference materials include the Redux DevTools Remote Monitoring docs[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=3,Channel%20of%20Events)[scaler.com](https://www.scaler.com/topics/react/redux-devtools/#:~:text=We%20can%20use%20log%20or,before%20the%20connection%20was%20established), the remotedev-server README for server options and GraphQL[github.com](https://github.com/zalmoxisus/remotedev-server#:~:text=Save%20reports%20and%20logs), and the internal implementation code for the DevTools enhancer[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,type%20%3D%3D%3D%20%27DISCONNECTED%27%29)[stackoverflow.com](https://stackoverflow.com/questions/76595014/redux-devtools-with-expo-49-beta-react-native-hermes-engine#:~:text=,%2F%2F%20Prevent%20flooding), which clarifies how messages are handled. These sources are cited inline to provide further detail and confirmation of behaviors described.